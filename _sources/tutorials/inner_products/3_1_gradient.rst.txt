
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials\inner_products\3_1_gradient.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_inner_products_3_1_gradient.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_inner_products_3_1_gradient.py:


Gradient Operator
=================

When solving PDEs using the finite volume approach, inner products may
contain the gradient operator. Where :math:`\phi` is a scalar quantity
and :math:`\vec{u}` is a vector quantity, we may need to derive a
discrete approximation to the following inner product:

.. math::
    (\vec{u} , \nabla \phi) = \int_\Omega \, \vec{u} \cdot \nabla \phi \, dv

In this section, we demonstrate how to go from the inner product to the
discrete approximation. In doing so, we must construct
discrete differential operators, inner product matricies and consider
boundary conditions.

.. GENERATED FROM PYTHON SOURCE LINES 22-60

Background Theory
-----------------

For the inner product between a vector :math:`\vec{u}` and
the gradient of a scalar :math:`\phi`,
there are two options for where the variables should live.

**For** :math:`\boldsymbol{\phi}` **on the nodes and** :math:`\boldsymbol{u}` **on cell edges:**

.. math::
    \int_\Omega \vec{u} \cdot \nabla \phi \, dv \approx \boldsymbol{u^T M_e G \, \phi}

where

    - :math:`\boldsymbol{M_e}` is the basic inner product matrix for vectors at edges
    - :math:`\boldsymbol{G}` is the discrete gradient operator which maps from nodes to edges

**For** :math:`\boldsymbol{\phi}` **at cell centers and** :math:`\boldsymbol{u}` **on cell faces**,
the gradient operator would have to map from cell centers to faces. This would require knowledge
of :math:`\phi` outside the domain for boundary faces. In this case, we use the identity
:math:`\vec{u} \cdot \nabla \phi = \nabla \cdot \phi\vec{u} - \phi \nabla \cdot \vec{u}`
and apply the divergence theorem such that:

.. math::
    \int_\Omega \vec{u} \cdot \nabla \phi \, dv =
    - \int_\Omega \phi \nabla \cdot \vec{u} \, dv + \oint_{\partial \Omega} \phi \hat{n} \cdot \vec{u} \, da
    \approx - \boldsymbol{u^T D^T M_c \, \phi} + \boldsymbol{u^T B \, \phi}
    = \boldsymbol{u^T \tilde{G} \, \phi}

where

    - :math:`\boldsymbol{D}` is the discrete divergence operator from faces to cell centers
    - :math:`\boldsymbol{M_c}` is the basic inner product matrix for scalars at cell centers
    - :math:`\boldsymbol{B}` is a sparse matrix that imposes the boundary conditions on :math:`\phi`
    - :math:`\boldsymbol{\tilde{G}} = \boldsymbol{-D^T M_c + B}` acts as a modified gradient operator with boundary conditions imposed

Note that when :math:`\phi = 0` on the boundary, the term containing :math:`\boldsymbol{B}` is zero.


.. GENERATED FROM PYTHON SOURCE LINES 63-66

Import Packages
---------------


.. GENERATED FROM PYTHON SOURCE LINES 66-73

.. code-block:: default


    from discretize.utils import sdiag
    from discretize import TensorMesh
    import numpy as np
    import matplotlib.pyplot as plt









.. GENERATED FROM PYTHON SOURCE LINES 74-77

Gradient
--------


.. GENERATED FROM PYTHON SOURCE LINES 77-103

.. code-block:: default


    # Make basic mesh
    h = np.ones(10)
    mesh = TensorMesh([h, h, h])

    # Items required to perform u.T*(Me*Gn*phi)
    Me = mesh.getEdgeInnerProduct()  # Basic inner product matrix (edges)
    Gn = mesh.nodalGrad  # Nodes to edges gradient

    # Items required to perform u.T*(Mf*Gc*phi)
    Mf = mesh.getFaceInnerProduct()  # Basic inner product matrix (faces)
    mesh.setCellGradBC(["neumann", "dirichlet", "neumann"])  # Set boundary conditions
    Gc = mesh.cellGrad  # Cells to faces gradient

    # Plot Sparse Representation
    fig = plt.figure(figsize=(5, 6))

    ax1 = fig.add_subplot(121)
    ax1.spy(Me * Gn, markersize=0.5)
    ax1.set_title("Me*Gn")

    ax2 = fig.add_subplot(122)
    ax2.spy(Mf * Gc, markersize=0.5)
    ax2.set_title("Mf*Gc")





.. image:: /tutorials/inner_products/images/sphx_glr_3_1_gradient_001.png
    :alt: Me*Gn, Mf*Gc
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    Text(0.5, 1.0513468013468013, 'Mf*Gc')




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.207 seconds)


.. _sphx_glr_download_tutorials_inner_products_3_1_gradient.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: 3_1_gradient.py <3_1_gradient.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: 3_1_gradient.ipynb <3_1_gradient.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
