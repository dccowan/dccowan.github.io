


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Averaging &mdash; discretize 0.6.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/logo-block.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Differential Operators" href="operators_differential.html" />
    <link rel="prev" title="Interpolation" href="operators_interpolation.html" />
 

<meta name="description" content="Simulation and Parameter Estimation in Geophysics">
<meta name="author" content="SimPEG Developers">
<meta name="keywords" content="python, geophysics, inversion, electromagnetics, magnetotellurics, magnetics, gravity, DC, flow inverse problems, open source, finite volume">


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45185336-1', 'auto');
  ga('send', 'pageview');

</script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> discretize
          

          
          </a>

          
            
            
              <div class="version">
                0.6.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../big_picture.html">Why discretize?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../additional_resources.html">Additional Resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/mesh_generation/index.html">Mesh Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/operators/index.html">Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/inner_products/index.html">Inner Products</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/pde/index.html">Solving PDEs</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">Theory</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../finite_volume_index.html">Intoduction to Finite Volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="meshes_index.html">Meshes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="operators_index.html">Operators</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="operators_interpolation.html">Interpolation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Averaging</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#averaging-matrices-in-1d">Averaging Matrices in 1D</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nodes-to-cell-centers">Nodes to Cell Centers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cell-centers-to-nodes">Cell Centers to Nodes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#averaging-scalars-in-2d-and-3d">Averaging Scalars in 2D and 3D</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Nodes to Cell Centers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Cell Centers to Nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#faces-to-cell-centers">Faces to Cell Centers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#edges-to-cell-centers">Edges to Cell Centers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#averaging-vectors-in-2d-and-3d">Averaging Vectors in 2D and 3D</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">Faces to Cell Centers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Edges to Cell Centers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="operators_differential.html">Differential Operators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="inner_products_index.html">Inner Products</a></li>
<li class="toctree-l1"><a class="reference internal" href="derivation_examples_index.html">Solving PDEs Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">Meta Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../release/index.html">Release Notes</a></li>
</ul>

            
          

    
        <p class="caption">
            <span class="caption-text">
            
                Getting connected
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://simpeg.xyz"><i class="fa fa-external-link-square fa-fw"></i> SimPEG</a></li>
            
                <li class="toctree-l1"><a href="http://slack.simpeg.xyz"><i class="fa fa-comment fa-fw"></i> Contact</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/simpeg/discretize"><i class="fa fa-github fa-fw"></i> Source Code</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">discretize</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="operators_index.html">Operators</a> &raquo;</li>
        
      <li>Averaging</li>
    
    

    <li class="wy-breadcrumbs-aside">
        
            
                <a href="https://github.com/simpeg/discretize/edit/master/doc/content/theory/operators_averaging.rst"
                   class="fa fa-github"> Edit this page</a>
            
        
        
    </li>

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="averaging">
<span id="operators-averaging"></span><h1>Averaging<a class="headerlink" href="#averaging" title="Permalink to this headline">¶</a></h1>
<p>Here, we provide the background theory for how discrete averaging matricies are formed.
Averaging matrices are required when quantities that live on different
parts of the mesh need to be added, subtracted, multiplied or divided.
Averaging matrices are built using the same principles that were discussed when forming <a class="reference internal" href="operators_interpolation.html#operators-interpolation"><span class="std std-ref">interpolation matrices</span></a>;
except the locations of the original quantity and the interpolated quantity are organized on a structured grid.</p>
<p>Where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a discrete representation of a vector living somewhere on the mesh (nodes, edges, faces),
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is the vector containing the averages mapped to another part of the mesh,
we look to constructs an averaging matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> such that:</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-general">
<span class="eqno">(1)<a class="headerlink" href="#equation-operators-averaging-general" title="Permalink to this equation">¶</a></span>\[\bar{\boldsymbol{u}} = A \, \boldsymbol{u}\]</div>
<p><strong>Tutorial:</strong> <a class="reference internal" href="../../tutorials/operators/1_averaging.html#sphx-glr-tutorials-operators-1-averaging-py"><span class="std std-ref">tutorial for constructing and applying averaging operators</span></a></p>
<div class="section" id="averaging-matrices-in-1d">
<h2>Averaging Matrices in 1D<a class="headerlink" href="#averaging-matrices-in-1d" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nodes-to-cell-centers">
<h3>Nodes to Cell Centers<a class="headerlink" href="#nodes-to-cell-centers" title="Permalink to this headline">¶</a></h3>
<p>Let us define a 1D mesh where cell center and node locations are defined according to the figure below.
The widths of the cells are given by <span class="math notranslate nohighlight">\(\Delta x_i\)</span>.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="../../_images/averaging_1d.png"><img alt="../../_images/averaging_1d.png" src="../../_images/averaging_1d.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">A 1D tensor mesh denoting the node and cell center locations.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>If <span class="math notranslate nohighlight">\(u(x)\)</span> is a scalar function whose values are known at the nodes
and <span class="math notranslate nohighlight">\(\bar{u}_i\)</span> is the average value at the center of cell <span class="math notranslate nohighlight">\(i\)</span>,
then:</p>
<div class="math notranslate nohighlight">
\[\bar{u}_i = \frac{u_{i-\tfrac{1}{2}} + u_{i+\tfrac{1}{2}}}{2}\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(A\)</span> that averages the values
at the nodes and places them at the cell centers, i.e.:</p>
<div class="math notranslate nohighlight">
\[\bar{\boldsymbol{u}} = A \, \boldsymbol{u}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u(x)\)</span> at the nodes,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the averages at cell centers.</p>
<p>For the entire mesh, the averaging matrix is given by:</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-n2c-1d">
<span class="eqno">(2)<a class="headerlink" href="#equation-operators-averaging-n2c-1d" title="Permalink to this equation">¶</a></span>\[\begin{split}A = \frac{1}{2} \begin{bmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp;1 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 1
\end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix. Defining <span class="math notranslate nohighlight">\(nc\)</span> as the number of cells in the mesh,
<span class="math notranslate nohighlight">\(A\)</span> is has shape <span class="math notranslate nohighlight">\(nc\)</span> by <span class="math notranslate nohighlight">\(nc \! + \! 1\)</span>.</p>
</div>
<div class="section" id="cell-centers-to-nodes">
<h3>Cell Centers to Nodes<a class="headerlink" href="#cell-centers-to-nodes" title="Permalink to this headline">¶</a></h3>
<p>Let us re-examine the figure illustrating the 1D mesh and assume we know the value of the function <span class="math notranslate nohighlight">\(u(x)\)</span> at cell centers.
Note that the nodes are not equal distance from the cell centers on either side.
Therefore we cannot simply sum the values and divide by half. Instead we need to implement a weighted averaging.</p>
<p>If <span class="math notranslate nohighlight">\(u(x)\)</span> is a scalar function whose values are known at the cell centers
and <span class="math notranslate nohighlight">\(\bar{u}_i\)</span> is the average value at the nodes,
then:</p>
<div class="math notranslate nohighlight">
\[\bar{u}_{i+\frac{1}{2}} = \Bigg ( \frac{\Delta x_{i+1}}{\Delta x_i + \Delta x_{i+1}} \Bigg ) u_{i}
+ \Bigg ( \frac{\Delta x_i}{\Delta x_i + \Delta x_{i+1}} \Bigg ) u_{i+1}\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\bar{A}\)</span> that averages the values
at the cell centers and places them at the nodes, i.e.:</p>
<div class="math notranslate nohighlight">
\[\bar{\boldsymbol{u}} = \bar{\boldsymbol{A}} \, \boldsymbol{u}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u(x)\)</span> at cell centers,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the averages at the nodes.</p>
<p>For the entire mesh, the averaging matrix is given by:</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-c2n-1d">
<span class="eqno">(3)<a class="headerlink" href="#equation-operators-averaging-c2n-1d" title="Permalink to this equation">¶</a></span>\[\begin{split}\bar{A} = \frac{1}{2} \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
a_1 &amp; b_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; a_2 &amp; b_2 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; a_{nc-1} &amp; b_{nc-1} \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1
\end{bmatrix} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
\begin{split}
a_i &amp;= \frac{\Delta x_{i+1}}{\Delta x_i + \Delta x_{i+1}} \\
&amp; \\
b_i &amp;= \frac{\Delta x_i}{\Delta x_i + \Delta x_{i+1}}
\end{split}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{A}\)</span> is a sparse matrix. Defining <span class="math notranslate nohighlight">\(nc\)</span> as the number of cells in the mesh,
<span class="math notranslate nohighlight">\(\bar{A}\)</span> has shape <span class="math notranslate nohighlight">\(nc \! + \! 1\)</span> by <span class="math notranslate nohighlight">\(nc\)</span>. Note that <span class="math notranslate nohighlight">\(\bar{A}_{0,0}\)</span> and <span class="math notranslate nohighlight">\(\bar{A}_{nc,nc-1}\)</span>
are equal to 1. This is because cell center locations needed to compute the average lie outside the mesh
and we must extrapolate using the nearest neighbour.</p>
</div>
</div>
<div class="section" id="averaging-scalars-in-2d-and-3d">
<h2>Averaging Scalars in 2D and 3D<a class="headerlink" href="#averaging-scalars-in-2d-and-3d" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Nodes to Cell Centers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>For a 2D mesh, the value of the function at 4 locations is needed to average from nodes to cell centers.
Let us define a 2D mesh where cell center locations <span class="math notranslate nohighlight">\((x_i, y_j)\)</span> are represented using indices <span class="math notranslate nohighlight">\((i,j)\)</span>.
The widths of the cells in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are given by <span class="math notranslate nohighlight">\(\Delta x_i\)</span> and <span class="math notranslate nohighlight">\(\Delta y_j\)</span>, respectively.</p>
<div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="../../_images/averaging_2d.png"><img alt="../../_images/averaging_2d.png" src="../../_images/averaging_2d.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-text">A 2D tensor mesh which shows the indexing for node and cell center locations.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>If <span class="math notranslate nohighlight">\(u(x,y)\)</span> is a scalar function whose values are known at the nodes
and <span class="math notranslate nohighlight">\(\bar{u} (i,j)\)</span> is the average at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>,
then:</p>
<div class="math notranslate nohighlight">
\[\bar{u}(i,j) = \frac{1}{4} \Big [
u \Big ( i-\tfrac{1}{2}, j-\tfrac{1}{2} \Big ) +
u \Big ( i+\tfrac{1}{2}, j-\tfrac{1}{2} \Big ) +
u \Big ( i-\tfrac{1}{2}, j+\tfrac{1}{2} \Big ) +
u \Big ( i+\tfrac{1}{2}, j+\tfrac{1}{2} \Big ) \Big ]\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> that averages the values
at the nodes and places them at the cell centers, i.e.:</p>
<div class="math notranslate nohighlight">
\[\bar{\boldsymbol{u}} = \boldsymbol{A \, u}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u(x,y)\)</span> at the nodes,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the averages at cell centers.</p>
<p>For tensor meshes, the averaging matrix is rather easy to construct.
Using equation <a class="reference internal" href="#equation-operators-averaging-n2c-1d">(2)</a>, the number of cells in the x-direction
can be used to construct a matrix <span class="math notranslate nohighlight">\(A_x\)</span>. And the number of cells in the y-direction
can be used to construct a matrix <span class="math notranslate nohighlight">\(A_y\)</span>. The averaging matrix in 2D is given by:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = A_y \otimes A_x\]</div>
<p>where <span class="math notranslate nohighlight">\(\otimes\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a>. For a 3D tensor mesh, the averaging matrix
from nodes to cell centers would be given by:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = A_z \otimes (A_y \otimes A_x)\]</div>
</div>
<div class="section" id="id2">
<h3>Cell Centers to Nodes<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>A nearly identical approach can be implemented to average from cell centers to nodes.
In this case, expression <a class="reference internal" href="#equation-operators-averaging-c2n-1d">(3)</a> is used to construct the 1D averaging
matricies in the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> (and <span class="math notranslate nohighlight">\(z\)</span>) directions using the dimensions of the cells
along each axis. Once again, nearest neighbour is used to assign a value to cell centers which lie outside the mesh.</p>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> that averages the values
at the cell centers and places them at the nodes, i.e.:</p>
<div class="math notranslate nohighlight">
\[\bar{\boldsymbol{u}} = \boldsymbol{A \, u}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u(x,y)\)</span> at the cell centers,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the averages at nodes.</p>
<p>For 2D averaging from cell centers to nodes, we use equation <a class="reference internal" href="#equation-operators-averaging-c2n-1d">(3)</a> and the cell widths
in the x and y directions to construct 1D averaging matrices <span class="math notranslate nohighlight">\(\bar{A}_x\)</span> and <span class="math notranslate nohighlight">\(\bar{A}_y\)</span>, respectively.
The averaging operator for a 2D tensor mesh is given by:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = \bar{A}_y \otimes \bar{A}_x\]</div>
<p>And for 3D averaging from cell centers to nodes:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = \bar{A}_z \otimes (\bar{A}_y \otimes \bar{A}_x)\]</div>
</div>
<div class="section" id="faces-to-cell-centers">
<h3>Faces to Cell Centers<a class="headerlink" href="#faces-to-cell-centers" title="Permalink to this headline">¶</a></h3>
<p>Let us define a 2D mesh where cell center locations <span class="math notranslate nohighlight">\((x_i, y_j)\)</span> are represented using indices <span class="math notranslate nohighlight">\((i,j)\)</span>.
The widths of the cells in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are given by <span class="math notranslate nohighlight">\(\Delta x_i\)</span> and <span class="math notranslate nohighlight">\(\Delta y_j\)</span>, respectively.</p>
<div class="figure align-center" id="id7">
<a class="reference internal image-reference" href="../../_images/averaging_2d_faces.png"><img alt="../../_images/averaging_2d_faces.png" src="../../_images/averaging_2d_faces.png" style="width: 350px;" /></a>
<p class="caption"><span class="caption-text">A 2D tensor mesh which shows the indexing for face and cell center locations.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>If <span class="math notranslate nohighlight">\(u(x,y)\)</span> is a scalar quantity whose values are known on the faces.
and <span class="math notranslate nohighlight">\(\bar{u}(i,j)\)</span> is the average at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>,
then:</p>
<div class="math notranslate nohighlight">
\[\bar{u}(i,j) = \frac{1}{4} \Big [
u \Big ( i-\tfrac{1}{2}, j \Big ) +
u \Big ( i+\tfrac{1}{2}, j \Big ) +
u \Big ( i, j-\tfrac{1}{2} \Big ) +
u \Big ( i, j+\tfrac{1}{2} \Big ) \Big ]\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> that averages the values
on the faces and places them at the cell centers, i.e.:</p>
<div class="math notranslate nohighlight">
\[\bar{\boldsymbol{u}} = \boldsymbol{A \, u}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u(x,y)\)</span> on the x and y-faces,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the averages at cell centers.</p>
<p>Let <span class="math notranslate nohighlight">\(I_n\)</span> be an <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(n\)</span> identity matrix.
And use equation <a class="reference internal" href="#equation-operators-averaging-n2c-1d">(2)</a> to construct 1D averaging matrices <span class="math notranslate nohighlight">\(A_x\)</span> and <span class="math notranslate nohighlight">\(A_y\)</span>.
Then for a 2D tensor mesh, the averaging matrix has the form:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = \frac{1}{2} \begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{A_y} \end{bmatrix}\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-ai-f2c-2d">
<span class="eqno">(4)<a class="headerlink" href="#equation-operators-averaging-ai-f2c-2d" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\boldsymbol{A_x} &amp;= I_{ny} \otimes A_x \\
\boldsymbol{A_y} &amp;= A_y \otimes I_{nx}
\end{align}\end{split}\]</div>
<p>For a 3D tensor mesh, the averaging matrix takes the form:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = \frac{1}{3} \begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{A_y} &amp; \boldsymbol{A_z} \end{bmatrix}\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-ai-f2c-3d">
<span class="eqno">(5)<a class="headerlink" href="#equation-operators-averaging-ai-f2c-3d" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\boldsymbol{A_x} &amp;= I_{nz} \otimes ( I_{ny} \otimes A_x ) \\
\boldsymbol{A_y} &amp;= I_{nz} \otimes ( A_y \otimes I_{nx} ) \\
\boldsymbol{A_z} &amp;= A_z \otimes ( I_{ny} \otimes I_{nx} )
\end{align}\end{split}\]</div>
</div>
<div class="section" id="edges-to-cell-centers">
<h3>Edges to Cell Centers<a class="headerlink" href="#edges-to-cell-centers" title="Permalink to this headline">¶</a></h3>
<p>Let us define a 2D mesh where cell center locations <span class="math notranslate nohighlight">\((x_i, y_j)\)</span> are represented using indices <span class="math notranslate nohighlight">\((i,j)\)</span>.
The widths of the cells in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are given by <span class="math notranslate nohighlight">\(\Delta x_i\)</span> and <span class="math notranslate nohighlight">\(\Delta y_j\)</span>, respectively.</p>
<div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="../../_images/averaging_2d_edges.png"><img alt="../../_images/averaging_2d_edges.png" src="../../_images/averaging_2d_edges.png" style="width: 350px;" /></a>
<p class="caption"><span class="caption-text">A 2D tensor mesh which shows the indexing for edge and cell center locations.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>If <span class="math notranslate nohighlight">\(u(x,y)\)</span> is a scalar quantity whose values are known on the edges.
and <span class="math notranslate nohighlight">\(\bar{u}(i,j)\)</span> is the average at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>,
then:</p>
<div class="math notranslate nohighlight">
\[\bar{u}(i,j) = \frac{1}{4} \Big [
u \Big ( i, j-\tfrac{1}{2} \Big ) +
u \Big ( i, j+\tfrac{1}{2} \Big ) +
u \Big ( i-\tfrac{1}{2}, j \Big ) +
u \Big ( i+\tfrac{1}{2}, j \Big ) \Big ]\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> that averages the values
on the edges and places them at the cell centers, i.e.:</p>
<div class="math notranslate nohighlight">
\[\bar{\boldsymbol{u}} = \boldsymbol{A \, u}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u(x,y)\)</span> on the x and y-edges,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the averages at cell centers.</p>
<p>Let <span class="math notranslate nohighlight">\(I_n\)</span> be an <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(n\)</span> identity matrix.
And use equation <a class="reference internal" href="#equation-operators-averaging-n2c-1d">(2)</a> to construct 1D averaging matrices <span class="math notranslate nohighlight">\(A_x\)</span> and <span class="math notranslate nohighlight">\(A_y\)</span>.
Then for a 2D tensor mesh, the averaging matrix has the form:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = \frac{1}{2} \begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{A_y} \end{bmatrix}\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-ai-e2c-2d">
<span class="eqno">(6)<a class="headerlink" href="#equation-operators-averaging-ai-e2c-2d" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\boldsymbol{A_x} &amp;= A_x \otimes I_{ny} \\
\boldsymbol{A_y} &amp;= I_{nx} \otimes A_y
\end{align}\end{split}\]</div>
<p>For a 3D tensor mesh, the averaging matrix takes the form:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{A} = \frac{1}{3} \begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{A_y} &amp; \boldsymbol{A_z} \end{bmatrix}\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-operators-averaging-ai-e2c-3d">
<span class="eqno">(7)<a class="headerlink" href="#equation-operators-averaging-ai-e2c-3d" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\boldsymbol{A_x} &amp;= I_{nz} \otimes ( A_y \otimes A_x ) \\
\boldsymbol{A_y} &amp;= A_z \otimes ( I_{ny} \otimes A_x ) \\
\boldsymbol{A_z} &amp;= A_z \otimes ( A_y \otimes I_{nx} )
\end{align}\end{split}\]</div>
</div>
</div>
<div class="section" id="averaging-vectors-in-2d-and-3d">
<h2>Averaging Vectors in 2D and 3D<a class="headerlink" href="#averaging-vectors-in-2d-and-3d" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>Faces to Cell Centers<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(\vec{u}(x,y)\)</span> be a vector function that is known on the faces.
That is, <span class="math notranslate nohighlight">\(u_x (x,y)\)</span> lives on x-faces and <span class="math notranslate nohighlight">\(u_y(x,y)\)</span> lives on y-faces.
In this case, the x-faces are used to average the x-component
to cell centers and the y-faces are used to average the y-component to cell centers separately.</p>
<p>Let us define a 2D mesh where cell center locations <span class="math notranslate nohighlight">\((x_i, y_j)\)</span> are represented using indices <span class="math notranslate nohighlight">\((i,j)\)</span>.
The widths of the cells in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are given by <span class="math notranslate nohighlight">\(\Delta x_i\)</span> and <span class="math notranslate nohighlight">\(\Delta y_j\)</span>, respectively.</p>
<div class="figure align-center" id="id9">
<a class="reference internal image-reference" href="../../_images/averaging_2d_faces.png"><img alt="../../_images/averaging_2d_faces.png" src="../../_images/averaging_2d_faces.png" style="width: 350px;" /></a>
<p class="caption"><span class="caption-text">A 2D tensor mesh which shows the indexing for face and cell center locations.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>Where <span class="math notranslate nohighlight">\(\bar{u}_x (i,j)\)</span> is the average x-component at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>:</p>
<div class="math notranslate nohighlight">
\[\bar{u}_x (i,j) = \frac{1}{2} \Big [ u_x \Big ( i-\tfrac{1}{2},j \Big ) + u_x \Big ( i+\tfrac{1}{2},j \Big ) \Big ]\]</div>
<p>And where <span class="math notranslate nohighlight">\(\bar{u}_y (i,j)\)</span> is the average at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>:</p>
<div class="math notranslate nohighlight">
\[\bar{u}_y (i,j) = \frac{1}{2} \Big [ u_y \Big ( i,j-\tfrac{1}{2} \Big ) + u_y \Big ( i,j+\tfrac{1}{2} \Big ) \Big ]\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> that averages the vector components living
on the faces separately and places them at the cell centers.
Here, the operation <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}} = \boldsymbol{A \, u}\)</span> takes the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix} \bar{\boldsymbol{u}}_{\boldsymbol{x}} \\ \bar{\boldsymbol{u}}_{\boldsymbol{y}} \end{bmatrix} =
\begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; \boldsymbol{A_y} \end{bmatrix}
\begin{bmatrix} \boldsymbol{u_x} \\ \boldsymbol{u_y} \end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u_x(x,y)\)</span> and <span class="math notranslate nohighlight">\(u_y(x,y)\)</span> on their respective faces,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the x component and y component averages at cell centers.
Matrices <span class="math notranslate nohighlight">\(\boldsymbol{A_x}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{A_y}\)</span> are defined in expression <a class="reference internal" href="#equation-operators-averaging-ai-f2c-2d">(4)</a>.</p>
<p>In 3D, the corresponding averaging matrix is defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix} \bar{\boldsymbol{u}}_{\boldsymbol{x}} \\ \bar{\boldsymbol{u}}_{\boldsymbol{y}} \\ \bar{\boldsymbol{u}}_{\boldsymbol{z}} \end{bmatrix} =
\begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{0} &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; \boldsymbol{A_y} &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; \boldsymbol{0} &amp; \boldsymbol{A_z} \end{bmatrix}
\begin{bmatrix} \boldsymbol{u_x} \\ \boldsymbol{u_y} \\ \boldsymbol{u_z} \end{bmatrix}\end{split}\]</div>
<p>where matrices <span class="math notranslate nohighlight">\(\boldsymbol{A_x}\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{A_y}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{A_z}\)</span> are defined in expression <a class="reference internal" href="#equation-operators-averaging-ai-f2c-3d">(5)</a>.</p>
</div>
<div class="section" id="id4">
<h3>Edges to Cell Centers<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(\vec{u}(x,y)\)</span> be a vector function that is known on the edges.
That is, <span class="math notranslate nohighlight">\(u_x (x,y)\)</span> lives on x-edges and <span class="math notranslate nohighlight">\(u_y(x,y)\)</span> lives on y-edges.
In this case, the x-edges are used to average the x-component
to cell centers and the y-edges are used to average the y-component to cell centers separately.</p>
<p>Let us define a 2D mesh where cell center locations <span class="math notranslate nohighlight">\((x_i, y_j)\)</span> are represented using indices <span class="math notranslate nohighlight">\((i,j)\)</span>.
The widths of the cells in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are given by <span class="math notranslate nohighlight">\(\Delta x_i\)</span> and <span class="math notranslate nohighlight">\(\Delta y_j\)</span>, respectively.</p>
<div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="../../_images/averaging_2d_edges.png"><img alt="../../_images/averaging_2d_edges.png" src="../../_images/averaging_2d_edges.png" style="width: 350px;" /></a>
<p class="caption"><span class="caption-text">A 2D tensor mesh which shows the indexing for edge and cell center locations.</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>Where <span class="math notranslate nohighlight">\(\bar{u}_x (i,j)\)</span> is the average x-component at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>:</p>
<div class="math notranslate nohighlight">
\[\bar{u}_x (i,j) = \frac{1}{2} \Big [ u_x \Big ( i,j-\tfrac{1}{2} \Big ) + u_x \Big ( i,j+\tfrac{1}{2} \Big ) \Big ]\]</div>
<p>And where <span class="math notranslate nohighlight">\(\bar{u}_y (i,j)\)</span> is the average at the center of cell <span class="math notranslate nohighlight">\(i,j\)</span>:</p>
<div class="math notranslate nohighlight">
\[\bar{u}_y (i,j) = \frac{1}{2} \Big [ u_y \Big ( i-\tfrac{1}{2},j \Big ) + u_y \Big ( i+\tfrac{1}{2},j \Big ) \Big ]\]</div>
<p>Our goal is to construct a matrix <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span> that averages the vector components living
on the edges separately and places them at the cell centers.
Here, the operation <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}} = \boldsymbol{A \, u}\)</span> takes the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix} \bar{\boldsymbol{u}}_{\boldsymbol{x}} \\ \bar{\boldsymbol{u}}_{\boldsymbol{y}} \end{bmatrix} =
\begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; \boldsymbol{A_y} \end{bmatrix}
\begin{bmatrix} \boldsymbol{u_x} \\ \boldsymbol{u_y} \end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> is a vector that stores the known values of <span class="math notranslate nohighlight">\(u_x(x,y)\)</span> and <span class="math notranslate nohighlight">\(u_y(x,y)\)</span> on their respective edges,
and <span class="math notranslate nohighlight">\(\bar{\boldsymbol{u}}\)</span> is a vector that stores the x component and y component averages at cell centers.
Matrices <span class="math notranslate nohighlight">\(\boldsymbol{A_x}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{A_y}\)</span> are defined in expression <a class="reference internal" href="#equation-operators-averaging-ai-e2c-2d">(6)</a>.</p>
<p>In 3D, the corresponding averaging matrix is defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix} \bar{\boldsymbol{u}}_{\boldsymbol{x}} \\ \bar{\boldsymbol{u}}_{\boldsymbol{y}} \\ \bar{\boldsymbol{u}}_{\boldsymbol{z}} \end{bmatrix} =
\begin{bmatrix} \boldsymbol{A_x} &amp; \boldsymbol{0} &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; \boldsymbol{A_y} &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; \boldsymbol{0} &amp; \boldsymbol{A_z} \end{bmatrix}
\begin{bmatrix} \boldsymbol{u_x} \\ \boldsymbol{u_y} \\ \boldsymbol{u_z} \end{bmatrix}\end{split}\]</div>
<p>where matrices <span class="math notranslate nohighlight">\(\boldsymbol{A_x}\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{A_y}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{A_z}\)</span> are defined in expression <a class="reference internal" href="#equation-operators-averaging-ai-e2c-3d">(7)</a>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="operators_differential.html" class="btn btn-neutral float-right" title="Differential Operators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="operators_interpolation.html" class="btn btn-neutral float-left" title="Interpolation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
<div role="contentinfo">
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/" width="60px"; style="float:right;height:3em;line-height:3em;padding:10px 0 0 1em;">
        <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    2013-2020,
    <a href="http://simpeg.xyz">SimPEG Developers.</a><br />
    Except where noted, this work is licensed under a <br />
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        Creative Commons Attribution 4.0 International License
    </a>
</div>
<br>
<div>
Built with
    <a href="http://sphinx-doc.org/">Sphinx</a>
    using a
    <a href="https://github.com/snide/sphinx_rtd_theme">theme</a>
    provided by
    <a href="https://readthedocs.org">Read the Docs</a>.
 </div>


</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>